#!perl
# PODNAME: rpio
# ABSTRACT: Repositorio Repository Management

use strict;
use warnings;

use Config::General;
use Getopt::Long;
use Log::Dispatch;
use Pod::Usage;
use POSIX qw/ strftime /;

use App::Repositorio;
use App::Repositorio::Logger;

# VERSION

my $config_file = '/etc/repositorio.conf';
my $log_level;
my $verbose;
my $help;
my $app_options = {};

GetOptions(
  # App Options
  'action|a=s' => \$app_options->{'action'},
  'arch=s'     => \$app_options->{'arch'},
  'checksums'  => \$app_options->{'checksums'},
  'file|f=s@'  => \$app_options->{'file'},
  'force|f'    => \$app_options->{'force'},
  'format=s'   => \$app_options->{'format'},
  'regex'      => \$app_options->{'regex'},
  'repo|r=s'   => \$app_options->{'repo'},
  'src-tag=s'  => \$app_options->{'src-tag'},
  'symlink'    => \$app_options->{'symlink'},
  'tag=s'      => \$app_options->{'tag'},
  'verbose|v'  => \$verbose,
  'ignore-errors' => \$app_options->{'ignore-errors'},
  # Script options
  'config-file|C=s' => \$config_file,
  'log-level=s'    => \$log_level,
  'h|help'         => \$help,
)
or pod2usage(-verbose=>2, -output => \*STDERR);

pod2usage(-verbose=>2, -output => \*STDERR) if $help;
pod2usage(-verbose=>1, -output => \*STDERR) unless $app_options->{'action'};

# allow comma list and/or multiply --file definitions
$app_options->{'file'} = [ split(',',join(',',@{$app_options->{'file'}})) ]
  if $app_options->{'file'};

my $conf_o = Config::General->new(
    -ConfigFile         => $config_file,
    -UseApacheInclude   => 1,
    -IncludeDirectories => 1,
    -IncludeGlob        => 1,
    -IncludeRelative    => 1,
    -IncludeAgain       => 1,
    -AllowMultiOptions  => 1,
);
my $config = {$conf_o->getall};

# Setup Default Config
$config->{tag_style}      ||= 'bottomdir'; # FIXME document this
$config->{log_file_level} ||= 'info'; # FIXME document this
$config->{screen_level}   ||= 'notice';
# We allow the cli to override the config for ScreenLevel
$config->{screen_level} = $log_level if $log_level;
$config->{screen_level} = 'debug' if $verbose;

# Setup Logging
my @log_outputs = (
  [
    'Screen',
    'min_level' => $config->{screen_level},
    stderr      => 0,
    newline     => 1,
  ],
);

my @callbacks;
if ($config->{log_file}) {
  push @log_outputs, [
    'File',
    'min_level' => $config->{log_file_level}, # FIXME document this
    'filename'  => $config->{log_file}, # FIXME document this
    'newline'   => 1,
    'mode'      => '>>', # append
  ];
  push @callbacks, sub {my %p=@_; return strftime('%F %T %z: ',localtime) . $p{message}};
}

my $logger = Log::Dispatch->new(
    outputs   => \@log_outputs,
    callbacks => \@callbacks,
    );
$logger->debug('logging initialized.');
App::Repositorio::Logger->load($logger);

my $a = App::Repositorio->new(config => $config);
my $action = delete $app_options->{'action'};
# Params::Validate does not like undef which GetOptions will fill with options
for my $param (keys %{$app_options}) {
  delete $app_options->{$param}
      unless defined $app_options->{$param};
}
$a->go($action, $app_options) unless caller();

exit 0

__END__

=pod

=encoding utf8

=head1 DESCRIPTION

Repositorio is designed to be an extensible repository management system
Currently it provides a basic framework and support for Yum based repositories.
Stay tuned for more!

=head1 SYNOPSIS

  rpio --action X [options]

  See perldoc App::Repositorio for all valid actions and their in depth descriptions

  Actions:
    list      List all configured repositories
      optional:
        --repo $repository_name
        --format (default|csv|json)
    mirror    Mirror a repository
      requires:
        --repo (all|$regex|$repository_name)
      optional:
        --checksums
        --ignore-errors
        --regex (uses --repo value as a regex)
    tag       Tag a repository
      requires:
        --repo $repository_name
        --tag  $destination_tag
      optional:
        --src-tag $src_tag (defaults to 'head')
        --symlink (default false)
    clean     Cleans a repository of unreferenced files
      requires:
        --repo (all|$regex|$repository_name)
      optional:
        --regex (uses --repo value as a regex)
    init      Initialise a custom repository
      requires:
        --repo $repository_name
    diff      Difference between two tags (via metadata)
      requires:
        --repo $repository_name
        --arch $arch
        --tag  $tag_name
      optional:
        --src-tag $tag_name (defaults to 'head')
    add-file  Add files to a custom repository
      requires:
        --repo $repository_name
        --arch $arch
        --file $path_to_file (--file can be comma delimited or supplied multiple times)
    del-file  Remove files from a custom repository
      requires:
        --repo $repository_name
        --arch $arch
        --file $path_to_file (--file can be comma delimited or supplied multiple times)

  Script Options:
    --config-file    Path to config-file, defaults to /etc/repositorio.conf
    --log-level      Change the stdout log level (overrides config, default: notice)
    --verbose        Synonym for --log-level=debug
    --help           This helpful message

=head1 EXAMPLES

  # Working with mirrored repos:

  # Update the repository from upstream to current
  rpio --action mirror --repo centos-6-epel
  # Tag the newly updated packages/manifests with a hard tag
  rpio --action tag --repo centos-6-epel --tag release_20150827
  # Tag the hard tag with a soft tag that your clients reference
  rpio --action tag --repo centos-6-epel --src-tag release_20150827 --symlink --tag production

  # Working with local repos:

  # Add some packages:
  rpio --action add-file --repo centos-6-custom --arch x86_64 --file /path/to/package_foo-1.0-el6.x86_64.rpm --file /path/to/package_bar-1.0-el6.x86_64.rpm
  # Tag the newly updated packages/manifests with a hard tag
  rpio --action tag --repo centos-6-custom --tag release_20150827
  # Tag the hard tag with a soft tag that your clients reference
  rpio --action tag --repo centos-6-epel --src-tag release_20150827 --symlink --tag production

  # Working with tags:
  # Lets say upstream added broken updates you can easily roll back your production tag just by:
  # --force is needed if a destination tag already exists
  rpio --action tag --repo $repo --src-tag $last_stable_releas_tag --symlink --tag production --force

=head1 CONFIGURATION

=head2 Global Options

=over 4

=item B<data_dir>

Path to location where repository files are stored eg:

  data_dir = /path/to/repo_data

=item B<include>

You can use this to include other conf files or directories eg:

  include /path/to/repos.conf
  include /path/to/conf.d

=item B<tag_style>

This determines how tag directories are done eg:

bottomdir (default) would result in a data structure like:

  $data_dir/$repo_name/$tag

topdir would result in a data structure like:

  $data_dir/$tag/$repo_name

=item B<log_file>

Path to log output to (No default) eg:

  log_file = /path/to/logfile.log

=item B<log_file_level>

Log messages to log file at this level (defaults to 'info')
Levels acceptable are what L<Log::Dispatch> supports

=item B<screen_level>

Same as log_level but to STDOUT...this value can be overwritten at runtime using --log-level
Defaults to 'notice'

=back

=head2 Global and/or repository

=over 4

=item B<hard_tag_regex>

If present, tag names must match this regex in order to be created.

This can be applied globally and per repository, in which case the repository takes precedence.

  hard_tag_regex = ^release_\d{8}$

Note: this regex is not applied against symlink tags

=item B<proxy>

You can use this setting to specify a http and https proxy eg:

  proxy = http://192.0.2.1:3128

This can also be specified on a per-repo basis or globally, the per-repo setting will be prefered over the global setting. So you can use a global proxy, with some repos using their own specific proxy.

Alternatively, since we are using L<HTTP::Tiny> internally various environment variables can also be used to specify a proxy to be used. Please consider this unsupported though, as we may change this out in the future without warning - and plugins may use whatever makes sense to them.

=item B<Repository Config>

A repository is defined as:

  <repo $reponame>
    $option1 = $value1
    ...
    $optionN = $valueN
  </>

Valid options include:

=over 4

=item type

The repository base type, ie Yum, Apt, Plain etc

=item local

The directory relative to $data_dir

=item url

The url to mirror from. If more than one is present, each will be tried in order.

The first which seems to return OK metadata will be used for the remainder of this invocation for this repo.

(Currently there are no smarts to share url health between repo config instances)

=item ca

An optional ca cert file used when mirroring from upstream https (ie like Redhats cdn network)

(only valid when I<url> is present)

=item cert

An optional cert file used when mirroring from upstream https (ie like Redhats cdn network)

(only valid when I<url> is present)

=item key

An optional cert key file used when mirroring from upstream https (ie like Redhats cdn network)

(only valid when I<url> is present)

=item include_filename

A regex applied to package filenames, if true the file is downloaded

(only valid when I<url> is present)

=item include_package

A regex applied to package metada name, if true the file is downloaded

(only valid when I<url> is present)

=item exclude_filename

A regex applied to package filenames, if true the file is NOT downloaded

(only valid when I<url> is present)

=item exclude_package

A regex applied to package metada name, if true the file is NOT downloaded

(only valid when I<url> is present)

=back

=back

=cut
